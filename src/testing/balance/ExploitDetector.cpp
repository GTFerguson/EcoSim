/**
 * @file ExploitDetector.cpp
 * @brief Implementation of balance exploit detection
 *
 * Refactored to generate structured recommendations with formula derivations
 * instead of hardcoded fix strings.
 */

#include "ExploitDetector.hpp"
#include "objects/creature/creature.hpp"
#include "world/Corpse.hpp"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cmath>

namespace EcoSim {
namespace Balance {

// Target efficiency ranges for recommendations
// Generous ranges to account for movement costs, failed hunts, maintenance, etc.
namespace TrophicConstants {
    constexpr float TARGET_EFFICIENCY_MIN = 0.20f;  // 20% - minimum viable for predators
    constexpr float TARGET_EFFICIENCY_MAX = 0.50f;  // 50% - maximum before imbalance
    constexpr float TARGET_EFFICIENCY_MID = 0.35f;  // 35% - target for calculations
}

namespace BreedingConstants {
    constexpr float TARGET_ROI_MIN = 0.40f;  // 40% - offspring worth less than cost (safe)
    constexpr float TARGET_ROI_MAX = 0.80f;  // 80% - approaching break-even (risky)
    constexpr float TARGET_ROI_MID = 0.60f;  // 60% - target for calculations
    // NOTE: ROI > 100% = exploit (infinite energy from breeding)
}

// Viability constants from Creature class
namespace ViabilityConstants {
    constexpr float RESOURCE_LIMIT = 10.0f;      // Max hunger/thirst
    constexpr float STARVATION_POINT = -0.1f;    // Death threshold
    constexpr float SAFETY_BUFFER = 1.5f;        // Buffer to avoid starving immediately after breeding
    constexpr float RESOURCE_SHARED = 4.0f;      // Fraction of resources shared (1/4)
    
    // Corpse value calculation chain constants (must match game code)
    constexpr float MIN_GENE_SIZE = 0.2f;        // Minimum MAX_SIZE gene value (from GeneLimits)
    constexpr float INFANT_EXPRESSION = 0.4f;    // Age modulation at birth (40% for infant stage)
    constexpr float HEALTH_PER_SIZE = 10.0f;     // MAX_SIZE → MaxHealth multiplier (creature.cpp)
    constexpr float CORPSE_DIVISOR = 50.0f;      // MaxHealth → CorpseSize divisor (main.cpp)
    
    // Effective minimum corpse size for newborn at minimum gene size
    // Formula: gene_size × infant_mod × health_per_size / corpse_divisor
    // = 0.2 × 0.4 × 10.0 / 50.0 = 0.016
    constexpr float MIN_OFFSPRING_SIZE = MIN_GENE_SIZE * INFANT_EXPRESSION * HEALTH_PER_SIZE / CORPSE_DIVISOR;
}

ExploitDetector::ExploitDetector(std::shared_ptr<Genetics::GeneRegistry> registry,
                                   const ArchetypeProfiler* profiler)
    : registry_(std::move(registry))
    , profiler_(profiler)
{
}

bool ExploitDetector::analyze() {
    if (!profiler_) {
        return false;
    }
    
    exploits_.clear();
    recommendations_.clear();
    maxSeverity_ = ExploitSeverity::INFO;
    
    // Run all detection rules (only for existing game parameters)
    detectBabyCannibalism();
    detectCorpseValueImbalance();
    
    // Run LP optimization analysis
    optimizer_.initializeDefaults();
    optimizationResult_ = optimizer_.optimize();
    
    hasRun_ = true;
    return true;
}

void ExploitDetector::detectBabyCannibalism() {
    // Rule 1: Baby Cannibalism Exploit
    // If breeding ROI > 1.0 for meat-eaters, they can generate infinite energy
    
    const auto& profiles = profiler_->getProfiles();
    std::vector<std::string> affected;
    float worstROI = 0.0f;
    float minOffspringSize = ViabilityConstants::MIN_OFFSPRING_SIZE;
    
    for (const auto& p : profiles) {
        if (p.reproductionROI > 1.0f) {
            affected.push_back(p.archetypeName);
            if (p.reproductionROI > worstROI) {
                worstROI = p.reproductionROI;
            }
        }
    }
    
    if (!affected.empty()) {
        // Current values from game constants
        float currentBreedCost = Creature::BREED_COST;
        float totalBreedCost = currentBreedCost * 2.0f;
        float nutritionPerSize = world::Corpse::NUTRITION_PER_SIZE;
        float minOffspringCorpse = minOffspringSize * nutritionPerSize;
        
        // ============================================================
        // VIABILITY ANALYSIS: Can we fix this by adjusting BREED_COST alone?
        // ============================================================
        float minBreedCostToPreventExploit = minOffspringCorpse / 2.0f;
        float resourcesShared = ViabilityConstants::RESOURCE_LIMIT / ViabilityConstants::RESOURCE_SHARED;
        float maxSurvivableBreedCost = ViabilityConstants::RESOURCE_LIMIT
                                       - resourcesShared
                                       - ViabilityConstants::SAFETY_BUFFER
                                       - std::abs(ViabilityConstants::STARVATION_POINT);
        
        bool constraintsCompatible = (minBreedCostToPreventExploit <= maxSurvivableBreedCost);
        
        // Calculate current ROI for all recommendations
        float currentROI = minOffspringCorpse / totalBreedCost;
        
        // Generate structured recommendations for this exploit
        std::vector<BalanceRecommendation> exploitRecs;
        
        // Option A: Increase BREED_COST to achieve target ROI
        // Formula: target_ROI = offspring_corpse / (2 × BREED_COST)
        // Therefore: BREED_COST = offspring_corpse / (2 × target_ROI)
        {
            BalanceRecommendation rec;
            rec.parameterName = "Creature::BREED_COST";
            rec.currentValue = currentBreedCost;
            float targetBreedCost = minOffspringCorpse / (2.0f * BreedingConstants::TARGET_ROI_MID);
            rec.targetValue = targetBreedCost;
            rec.currentROI = currentROI;
            rec.expectedROI = BreedingConstants::TARGET_ROI_MID;
            rec.derivationFormula = "BREED_COST = offspring_corpse / (2 × target_ROI)";
            
            if (targetBreedCost > maxSurvivableBreedCost) {
                rec.rationale = "⚠️ INFEASIBLE: Requires " + formatFloat(targetBreedCost, 1) +
                               " but max survivable is " + formatFloat(maxSurvivableBreedCost, 1) +
                               " (parents would die)";
            } else {
                rec.rationale = "✓ FEASIBLE: Achieves " +
                               std::to_string(static_cast<int>(BreedingConstants::TARGET_ROI_MID * 100.0f)) +
                               "% target ROI";
            }
            exploitRecs.push_back(rec);
            recommendations_.push_back(rec);
        }
        
        // Option B: Reduce NUTRITION_PER_SIZE to achieve target ROI
        // Formula: target_ROI = (size × NUTRITION) / (2 × BREED_COST)
        // Therefore: NUTRITION = (2 × BREED_COST × target_ROI) / size
        {
            BalanceRecommendation rec;
            rec.parameterName = "Corpse::NUTRITION_PER_SIZE";
            rec.currentValue = nutritionPerSize;
            float targetNutrition = (2.0f * currentBreedCost * BreedingConstants::TARGET_ROI_MID) / minOffspringSize;
            rec.targetValue = targetNutrition;
            rec.currentROI = currentROI;
            rec.expectedROI = BreedingConstants::TARGET_ROI_MID;
            rec.derivationFormula = "NUTRITION = (2 × BREED_COST × target_ROI) / MIN_OFFSPRING_SIZE";
            float newOffspringValue = minOffspringSize * targetNutrition;
            rec.rationale = "✓ FEASIBLE: Reduces offspring corpse to " + formatFloat(newOffspringValue, 1) +
                           " cal (target " +
                           std::to_string(static_cast<int>(BreedingConstants::TARGET_ROI_MID * 100.0f)) +
                           "% ROI)";
            exploitRecs.push_back(rec);
            recommendations_.push_back(rec);
        }
        
        std::ostringstream desc;
        desc << std::fixed << std::setprecision(1);
        desc << "Carnivores/omnivores can breed and eat offspring for net energy gain.\n";
        desc << "  INPUTS:\n";
        desc << "    BREED_COST = " << currentBreedCost << " per parent\n";
        desc << "    NUTRITION_PER_SIZE = " << nutritionPerSize << " calories/size\n";
        desc << "    MIN_OFFSPRING_SIZE = " << minOffspringSize << "\n";
        desc << "    RESOURCE_LIMIT = " << ViabilityConstants::RESOURCE_LIMIT << " (max hunger/thirst)\n";
        desc << "    STARVATION_POINT = " << ViabilityConstants::STARVATION_POINT << " (death threshold)\n";
        desc << "  CALCULATION:\n";
        desc << "    Total breed cost = 2 × " << currentBreedCost << " = " << totalBreedCost << " calories\n";
        desc << "    Min offspring corpse = " << minOffspringSize << " × " << nutritionPerSize << " = " << minOffspringCorpse << " calories\n";
        desc << "  RESULT:\n";
        desc << "    Current ROI = " << minOffspringCorpse << " / " << totalBreedCost << " = " << formatFloat(worstROI, 1) << "x\n";
        desc << "    (ROI > 1.0 means infinite energy exploit)\n\n";
        
        desc << "  VIABILITY ANALYSIS:\n";
        desc << "    Min BREED_COST to prevent exploit = " << minBreedCostToPreventExploit << " per parent\n";
        desc << "    Max BREED_COST parents can survive = " << maxSurvivableBreedCost << " per parent\n";
        desc << "    Constraints compatible? " << (constraintsCompatible ? "YES" : "NO - IMPOSSIBLE TO FIX WITH BREED_COST ALONE") << "\n";
        
        ExploitSeverity severity = ExploitSeverity::CRITICAL;
        addExploit("Baby Cannibalism", severity, desc.str(), exploitRecs, affected);
    }
}

void ExploitDetector::detectCorpseValueImbalance() {
    // Rule 3: Corpse Value Imbalance
    // If corpse value > lifetime energy consumption, creatures are "energy batteries"
    
    const auto& profiles = profiler_->getProfiles();
    std::vector<std::string> affected;
    float worstRatio = 0.0f;
    float avgCorpseValue = 0.0f;
    float avgLifetimeConsumption = 0.0f;
    int validCount = 0;
    
    for (const auto& p : profiles) {
        if (p.lifetimeConsumption > 0) {
            float ratio = p.corpseValue / p.lifetimeConsumption;
            if (ratio > 1.0f) {
                affected.push_back(p.archetypeName);
                if (ratio > worstRatio) {
                    worstRatio = ratio;
                }
            }
            avgCorpseValue += p.corpseValue;
            avgLifetimeConsumption += p.lifetimeConsumption;
            validCount++;
        }
    }
    
    if (validCount > 0) {
        avgCorpseValue /= validCount;
        avgLifetimeConsumption /= validCount;
    }
    
    if (!affected.empty()) {
        float nutritionPerSize = world::Corpse::NUTRITION_PER_SIZE;
        
        // Generate structured recommendation: target NUTRITION_PER_SIZE
        float avgSize = avgCorpseValue / nutritionPerSize;
        float targetNutrition = avgLifetimeConsumption / avgSize;
        float currentCorpseROI = avgCorpseValue / avgLifetimeConsumption;
        
        std::vector<BalanceRecommendation> exploitRecs;
        {
            BalanceRecommendation rec;
            rec.parameterName = "Corpse::NUTRITION_PER_SIZE";
            rec.currentValue = nutritionPerSize;
            rec.targetValue = targetNutrition;
            rec.currentROI = currentCorpseROI;
            rec.expectedROI = 1.0f;
            rec.derivationFormula = "NUTRITION_PER_SIZE = lifetime_consumption / size";
            rec.rationale = "✓ FEASIBLE: Corpse value matches energy consumed";
            exploitRecs.push_back(rec);
            recommendations_.push_back(rec);
        }
        
        std::ostringstream desc;
        desc << std::fixed << std::setprecision(1);
        desc << "Some archetypes have corpse values exceeding their lifetime energy consumption.\n";
        desc << "  INPUTS:\n";
        desc << "    NUTRITION_PER_SIZE = " << nutritionPerSize << " calories/size\n";
        desc << "    Avg corpse value = " << avgCorpseValue << " calories\n";
        desc << "    Avg lifetime consumption = " << avgLifetimeConsumption << " calories\n";
        desc << "  CALCULATION:\n";
        desc << "    Worst corpse/consumption ratio = " << worstRatio << "x\n";
        desc << "  RESULT:\n";
        desc << "    This means killing them yields more energy than they ever consumed.\n";
        desc << "    Effectively makes them 'energy batteries' that create net positive energy.";
        
        ExploitSeverity severity = (worstRatio > 2.0f)
            ? ExploitSeverity::WARNING
            : ExploitSeverity::INFO;
        addExploit("Corpse Value Imbalance", severity, desc.str(), exploitRecs, affected);
    }
}

void ExploitDetector::addExploit(const std::string& name,
                                   ExploitSeverity severity,
                                   const std::string& description,
                                   const std::vector<BalanceRecommendation>& recs,
                                   const std::vector<std::string>& affectedArchetypes) {
    ExploitReport report;
    report.exploitName = name;
    report.severity = static_cast<int>(severity);
    report.description = description;
    report.recommendations = recs;
    report.affectedArchetypes = affectedArchetypes;
    
    exploits_.push_back(report);
    updateMaxSeverity(severity);
}

void ExploitDetector::updateMaxSeverity(ExploitSeverity s) {
    if (static_cast<int>(s) > static_cast<int>(maxSeverity_)) {
        maxSeverity_ = s;
    }
}

int ExploitDetector::getCriticalCount() const {
    int count = 0;
    for (const auto& e : exploits_) {
        if (e.severity == static_cast<int>(ExploitSeverity::CRITICAL)) {
            ++count;
        }
    }
    return count;
}

std::string ExploitDetector::getResultsText() const {
    if (!hasRun_) {
        return "Analysis has not been run yet.\n";
    }
    
    std::ostringstream ss;
    
    ss << separator(100, '=') << "\n";
    ss << "SECTION 3: EXPLOIT DETECTION REPORT\n";
    ss << separator(100) << "\n\n";
    
    if (exploits_.empty()) {
        ss << "No balance exploits detected.\n";
        return ss.str();
    }
    
    ss << "Detected " << exploits_.size() << " potential exploit(s)\n";
    ss << "Highest severity: " << severityToString(maxSeverity_) << "\n\n";
    
    // Sort by severity (highest first)
    std::vector<ExploitReport> sorted = exploits_;
    std::sort(sorted.begin(), sorted.end(),
        [](const auto& a, const auto& b) { return a.severity > b.severity; });
    
    int exploitNum = 1;
    for (const auto& e : sorted) {
        ss << "\n" << separator(80, '=') << "\n";
        ss << "EXPLOIT #" << exploitNum++ << ": " << e.exploitName << "\n";
        ss << separator(80, '=') << "\n";
        ss << "Severity: " << severityToString(static_cast<ExploitSeverity>(e.severity)) << "\n\n";
        
        ss << "DESCRIPTION:\n" << e.description << "\n\n";
        
        if (!e.affectedArchetypes.empty()) {
            ss << "AFFECTED ARCHETYPES:\n  ";
            for (size_t i = 0; i < e.affectedArchetypes.size(); ++i) {
                if (i > 0) ss << ", ";
                ss << e.affectedArchetypes[i];
            }
            ss << "\n\n";
        }
        
        // Output inline recommendations for this exploit
        if (!e.recommendations.empty()) {
            ss << "RECOMMENDATIONS:\n";
            int recNum = 1;
            for (const auto& rec : e.recommendations) {
                ss << "\n  RECOMMENDATION #" << recNum++ << ": " << rec.parameterName << "\n";
                ss << "  " << separator(56, '-') << "\n";
                ss << "    Formula:   " << rec.derivationFormula << "\n";
                ss << "    Value:     " << std::setw(8) << std::left << rec.currentValue
                   << " ->    " << rec.targetValue << "\n";
                ss << "    ROI:       " << std::setw(8) << std::left
                   << (std::to_string(static_cast<int>(rec.currentROI * 100.0f)) + "%")
                   << " ->    " << static_cast<int>(rec.expectedROI * 100.0f) << "%\n";
                ss << "    Rationale: " << rec.rationale << "\n";
            }
            ss << "\n";
        }
    }
    
    return ss.str();
}

void ExploitDetector::contributeToReport(BalanceReport& report) const {
    if (!hasRun_) return;
    
    report.exploits = exploits_;
    report.recommendations = recommendations_;
}

} // namespace Balance
} // namespace EcoSim
